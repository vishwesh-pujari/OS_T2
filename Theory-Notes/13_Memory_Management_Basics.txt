Memory Management Basics:

When we say CPU, we mean Execution unit of the CPU. (fetch, decode, execute)

Memory layout - It is a view taken by the compiler while compiling a C program

$size /bin/ls - run size on elf files
there is no size calculation for stack and heap bcoz they are allocated on runtime.
One process should not be able to access data from other process. That's why we get segmentation fault when our pointer points to some other memory location.
Loader - read elf file and move it into RAM

Address binding - determining address of different components of a program. i.e. determining address of bss, data, code, , heap, etc.

Limit and relocation are 2 registers.
Relocation register - Base register

Location of Process in RAM = base(relocation) register
Total size of the process in RAM = limit register

MMU - memory management unit of processor
MMU is the part of processor.
Logical address is the address issued by execution unit of Processor.

MMU issues physical address. It actually adds the Base register.

In base + limit scheme, Compiler assumes that process starts from 0
OS remembers the values of Limit and relocation registers in its own data structures.

HW - It should be possible to have relocatable code even with "simplest case" - How?

In multiple base + limit pairs - there are different segments(different chunks of memory).

Indirection - commonly employed techniques in programming. I won't do it, you do it. Use of pointer is also indirection. Bcoz we are accessing variables using someone else that is pointer.

IA-32 : 32 Bit intel Architecture

Selector - index into the table.

When Multiple base + limit pairs are in memory, it is highly inefficient. Bcoz for conversion of an address needs memory address.

The address that we print in a C program using %p is a logical address.

Logical memory - view of compiler
Paging means not segmemtation world! Its a different world
Page table is a simple array.
Paging allowes us to load a process anywhere in the RAM. But a page is kept continuously in memory!
Page number = Byte Number / Page Size
Page table is set up by the OS in mem	ory

PTBR - Register - Page Table Base Register - points to page table in memory
p - page number - index in page table
d - offset

For paging scheme:
Once OS is done setting up PTBR, page table, essential hardware setup, schedule the Process, process runs on its own. The logical->physical address translation happens in Hardware!

Physical address = logical address given by the compiler + base

The OS sets up the hardware, and after that the hardware manages translation on its own

Segmentation and Paging are different concepts
But x86 provides both segmentation and paging.

Explanation: Multiple Base + Limit Pairs, with Furthur Indirection:
Address generated by CPU is logical address. It has an implied selecter. This selector is an  index in the table.
The descriptor table is an array of Base and Limit pairs.
Selector gives which Base+Limit is to be used.
The value of that Base in The table is added to the offset.
Problem with this approach is that it is highly inefficient as memory needs to be fetched for decoding the address. Memory access is slow.
